#
# Syntax for the definition of datatypes
#
datatypes:
  #
  # (1) Numerical values
  #
  # (1.1) predefined: integer, float
  #
  my_int_1: integer
  my_uint_1: unsigned_integer
  my_float_1: float
  #
  # (1.2) ranges
  #
  my_range_1: integer: {min: -1, max: 1}
  my_range_2: unsigned_integer: {min: 0, max: 100}
  my_range_3: float: {min: 0, max: 1}
  my_range_4: float: {min: 0, min_excluded: true, max: 1, max_excluded: true}
  #
  # (1.3) single value or set of predefined values
  #
  my_value: {constant: 3}
  my_values: {accepted_values: [1,2,3]}
  #
  # (2) strings
  #
  # (2.1) single values or set of predefined values
  #
  my_strtype_1: {constant: one}
  my_strtype_2: {accepted_values: [foo, bar]}
  #
  # (2.2) defined by regular expressions
  #
  my_retype_1: {regex: "[A-Z]{3}\d"}
  #
  # if a list is used, regexes are applied in the order:
  my_retype_3: {regexes: ["[A-Z]{3}\d", "[A-Z]{4}\d"]}
  #
  # - dictionary
  #
  # specify how to interpret each of (or some of) the possible values:
  my_strtype_3: {constant: {one: 1}}
  my_strtype_4: {accepted_values: [one: "1", "2"]}
  #
  # provide reverse translations if the map is not 1:1;
  # anything not provided in the reverse map is assumed to be a
  # valid string or a unique value
  my_strtype_5: {accepted_values: [one: 1, "1": 1, "2"],
                reverse: {1: "one"}}
  #
  # dictionary can also be used for regex; in this case
  # reverse translations are always requested
  my_retype_4: {regexes: ["[A-Z]{3}\d": 1, "[A-Z]{3}": 2],
                reverse: {1: "AAA3", 2: ABC}}
  #
  # - empty
  #
  # allow the element to be missing and specify which value shall be
  # used if the element is missing:
  my_optstrtype_1: {constant: {"$": true}, empty: false}
  #
  # also in this case a reverse map to make back-translations unique:
  my_optstrtype_2: {accepted_values: ["+": "positive", "-": "negative"],
                    empty: "positive", reverse: {"positive": ""}}
  #
  # (3) combined values
  #
  # (3.1) alternatives
  #
  # one of different types (previously defined, or defined inline)
  my_type_1: {one_of: [my_string_12, my_string_13, {regex: ".*"}]}
  # the type definitions are checked in the order given by the list
  #
  # (3.2) structures
  #
  # keys are the the structure element names;
  my_struct_1: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "[$+]"}]}
  #
  # types defined previously can be used too
  my_struct_2: {composed_of: [foo: my_type_2, bar: my_type_3]}
  #
  # a separator between the elements can be specified (fixed string):
  my_struct_3: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "\d+"}],
                sep: "."}
  #
  # a prefix or suffix or both can also be specified; these are constant
  # strings that shall be ignored when decoding the value (e.g. parenthesis)
  my_struct_4: {composed_of: [bar: type1, foo: type2],
                sep: ",", pfx: "(", sfx: ")"}
  #
  # can the structure be splitted by the separator? (sometimes the separator
  # can be contained in the last element, sometimes in any element if escaped);
  # if not, use split: false
  my_struct_5: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "\d+"}],
                sep: ".", split: false}
  #
  # as a particular case, the last element(s) of the structure can be omitted:
  # to allow this use last_optional: true
  my_struct_5: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "\d+"}],
                sep: ".", last_optional: true}
  #
  # in other cases, the last element can be either omitted
  # or included multiple times; to allow this, use varlen: true;
  # the element will be parsed as a list
  my_struct_6: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "\d+"}],
                sep: ".", varlen: true}
  #
  # when using varlen, it is optionally possible to check the number of
  # repetitions of the last element using min_n_lastelem (default: 0) and
  # max_n_lastelem (default: unlimited)
  my_struct_7: {composed_of: [foo: {regex: "\d+"}, bar: {regex: "\d+"}],
                sep: ".", varlen: true, min_n_lastelem: 1}
  #
  # additional key/value pairs can be added to the resulting decoded value
  # using the 'implicit' key:
  my_struct_8: {composed_of: [foo: foo_type, bar: bar_type],
                implicit: {baz: 1}}
  #
  # (3.3) lists
  #
  # lists require always a separator (which can be an empty string; and
  # as in structures, it is possible to specify split: false if necessary);
  # pfx and sfx can be specified;
  # minlength and maxlength may be optionally added:
  foo: {list_of: my_struct_1, sep: " ", minlength: 1, maxlength: 3}
  #
  # - empty
  #
  # can be used for alternatives and for lists (with no minlength)
  # and specifies a value to be used in case the list is empty (for lists)
  # or in case none of the alternatives applies (in case of alternatives)
  bar: {list_of: foo, empty: 1}
  zar: {one_of: [bar, foo], empty: "*"}
